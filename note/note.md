## Soft-RPC介绍

### RPC简介

> RPC(Remote Procedure Call,远程过程调用)用于实现部署在不同机器上的系统之间的方法调用，使得程序可以像访问本地服务一样，通过网络传输调用远程系统提供的服务。

具体而言：

- RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。
- RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯） RPC 是一个请求响应模型。
- 客户端发起请求，服务器返回响应（类似于Http的工作方式） RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。

web项目中，**调用本地服务的过程**：编写接口和实现类，然后将实现类托管至Spring容器，之后需要用到该服务时直接使用@Autowired将其注入即可。但在实际的开发环境中，并不是所有的服务都是由我们自己来进行开发，我们经常需要调用由别的开发人员开发的服务，那么通过使用RPC框架，在本地导入其他服务接口的依赖包之后，就可以类似上述过程一样去调用远程的服务。

- 为什么不直接在本地导入外部服务的接口+实现类的依赖包？

  实际开发环境中，接口的实现类通常很容易改变，如果该服务被大量的调用者所依赖，那么一旦这个服务的实现类发生改变，就要去发包让所有调用者更新本地的依赖包，系统耦合性增加；如果使用RPC的方式，则实现类只需要交给服务的提供者进行维护即可。

**调用远程服务的过程（RPC方式）：**

<img src="img\20191108234611174.png" alt="image-20191108234611174" style="zoom:80%;" />

1）服务消费方（client）调用以本地调用方式调用服务；

2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；

3）client stub找到服务地址，并将消息发送到服务端；

4）server stub收到消息后进行解码；

5）server stub根据解码结果调用本地的服务；

6）本地服务执行并将结果返回给server stub；

7）server stub将返回结果打包成消息并发送至消费方；

8）client stub接收到消息，并进行解码；

9）服务消费方得到最终结果。

RPC框架的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。从而使得用户对远程服务的调用可以像本地服务一样。

### 序列化及反序列化

#### **序列化/反序列化介绍**

- 序列化(Serialization)：将对象的状态信息转换为可存储或传输的形式的过程。
- 反序列化(Deserialization)：序列化的逆过程。将字节序列恢复为对象的过程。

**通过序列化可以解决的问题**

- 通过将对象序列化为字节数组，使得不共享内存通过网络连接的系统之间能够进行对象的传输；
- 通过将对象序列化为字节数组，可以将对象永久存储到存储设备；
- 解决远程接口调用JVM之间内存无法共享的问题。

**评价序列化算法优劣的指标**

- 序列化后码流的大小；
- 序列化本身的速度及系统资源开销大小（内存，CPU）。

#### 常用的序列化工具介绍

**JDK默认的序列化工具**

> JAVA原生序列化方式，主要通过对象输入流ObjectInputStream和对象输出流ObjectOutputStream来实现，序列化对象需要实现Serializable接口。

- 序列化时，只对对象的状态进行保存，而不管对象的方法；

- 父类实现序列化时，子类自动实现序列化，不需要显式实现Serializable接口；

- 一个对象的实例变量引用其他对象时，序列化该对象时也把引用对象进行序列化；

- 字段被声明为transient后，JDK默认序列化机制会忽略该字段。

  **优点：**

  - Java语言自带，无需引入第三方依赖；
  - 与Java有天然的最好的易用性与亲和性。

  **缺点：**

  - 只支持Java语言，不支持跨语言；
  - 性能欠佳，序列化后产生的码流大小过大，对引用过深的对象序列化可能导致OOM。

Java序列化会把要序列化的对象类的元数据和业务数据全部序列化为字节流，而且是把整个继承关系上的东西全部序列化了。它序列化出来的字节流是对那个对象结构到内容的完全描述，包含所有的信息，因此效率较低而且字节流比较大。但是由于确实是序列化了所有内容，所以可以说什么都可以传输，因此也更可用和可靠。

**Hessian**

> Hessian是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。序列化对象需要实现Serializable接口。

- Hessian相比Java原生序列化, 序列化后的二进制数据量更小, 因此传输速度和解析速度都更快

- 采用简单的结构化标记, 并且只存储对象数据内容部分, 而Java原生序列化还会存一些继承关系之类；
- 采用引用取代重复遇到的对象, 避免了重复编码；
- 支持多种不同语言。

**ProtoStuff**

protostuff 基于Google protobuf，但是提供了更多的功能和更简易的用法。其中，protostuff-runtime 实现了无需预编译对java bean进行protobuf序列化/反序列化的能力。protostuff-runtime的局限是序列化前需预先传入schema(可以由代码方法生成, 不需要手动改创建)，其中，schema中包含了对象进行序列化和反序列化的逻辑；反序列化不负责对象的创建只负责复制，因而**必须提供默认构造函数**。此外，protostuff 还可以按照protobuf的配置序列化成json/yaml/xml等格式。

在性能上，protostuff不输原生的protobuf，甚至有反超之势。

#### **序列化工具引擎**

本项目用到三种:Default / Hessian / ProtoStuff， 一个Serializer接口有多种实现类, 如何优雅的进行选择? 使用可配置化的序列化工具引擎，有两种实现思路：

- 工厂模式方案：

  添加一个工厂类, 提供根据名称获取Serializer实现类的方法, 最后用一个Engine类即可以实现优雅的选择。这样做的缺陷是每次序列化/反序列化请求都需要生成新的Serializer，消耗存储空间。

- 使用Map+Enum枚举类：

   添加一个枚举类, 其中主要存储代表不同实现类的枚举值。在Engine类里新增常量map， key存储枚举类里的不同枚举，value存储对应具体的Serializer实现类，Engine类加载时在static代码块初始化map，根据这个传入的Serializer名称在map中找对应的实现类对象，执行实际的功能方法。**可以解决单例问题**。

  <img src="img\image-20191110180140681.png" alt="image-20191110180140681" style="zoom:80%;" />
  
  **FactoryBean的作用**
  
  Spring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该FactoryBean的getObject方法所返回的对象。创建出来的对象是否属于单例由isSingleton中的返回决定。
  
  一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。
  
  FactoryBean 通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，用xml配置比较困难，这时可以考虑用FactoryBean。